# leetcode
#### 20 符号配对

利用stack判断符号是否配对

⚠️C++注意事项

* 头文件<stack>
* 基础类型有push，string类型或者自定义类型有emplace

#### 26 消除有序数组的重复字符&将不同字符调换到前k个

利用一个指针标记

⚠️C++注意事项

* vector的构造方式

  vector<int> vec(a,a+3); //从数组构造

* 数组的初始化方式

  int a[3] = {1,1,2};

#### 53 求某个区间的最大和

求取区间和用前缀差

分别用了三种方法：

* O(n*n) 暴力遍历所有可能解

* 每个i求最大值：当前sum值-前面最小前缀和，和最大值 比较，并且维护一个前面的最小前缀值

* 动态规划

  动态规划获得 以i为结尾的最大数组和

  那么d[0] d[1] ....d[i]中最大值就是所求值

#### 88 不使用额外空间合并两个有序数组

从后往前比较&从后往前插入

#### 104 获得一颗树的深度

* 递归 = 1+max（left.depth, right.depth)
* 使用一个queue进行bfs遍历

#### 121 获得最高股票数额

S:当前值-前面最小值

求s的最大值

#### 122 获得最高股票数额，不限交易次数

低点买入 高点卖出

极端点想：只要今天比昨天高，就可以卖出，因为一直找到最高处卖，等于中间的每天买入&卖出。

#### 125 判断字母类是否回文

palindrome:回文

⚠️ C++

* 正则替换的使用 //删除掉所有非字母的字符

  regex re("[^a-zA-Z】+");

  s = regex_replace(s,re,"");

* String.replace的使用

  只能单个字符进行替换

  s.replace(s.begin(),s.end()," ","");

* 大小写替换

  transform(s.begin(),s.end(),s.begin(),::tolower);

#### 136 一个非空数组包括n个出现两次的整数，1个出现一次的整数，找到这个整数

将所有的数字亦或，结果就是出现一次的整数

* 亦或：两个相同的数字得0，两个不同的数字得1，和0亦或为本身
* 两个不同位亦或为1，两个相同位亦或为0

#### 155 构造一个可以O(1)获得最小值的stack

构造两个stack，其中一个栈顶是当前最小值，如果大于它的就不入栈

#### 167 一个有序数组求和 twosum

两个指针