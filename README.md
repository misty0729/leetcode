# leetcode
#### 20 符号配对

利用stack判断符号是否配对

⚠️C++注意事项

* 头文件<stack>
* 基础类型有push，string类型或者自定义类型有emplace

#### 26 消除有序数组的重复字符&将不同字符调换到前k个

利用一个指针标记

⚠️C++注意事项

* vector的构造方式

  vector<int> vec(a,a+3); //从数组构造

* 数组的初始化方式

  int a[3] = {1,1,2};

#### 53 求某个区间的最大和

求取区间和用前缀差

分别用了三种方法：

* O(n*n) 暴力遍历所有可能解

* 每个i求最大值：当前sum值-前面最小前缀和，和最大值 比较，并且维护一个前面的最小前缀值

* 动态规划

  动态规划获得 以i为结尾的最大数组和

  那么d[0] d[1] ....d[i]中最大值就是所求值

#### 88 不使用额外空间合并两个有序数组

从后往前比较&从后往前插入

#### 104 获得一颗树的深度

* 递归 = 1+max（left.depth, right.depth)
* 使用一个queue进行bfs遍历

#### 121 获得最高股票数额

S:当前值-前面最小值

求s的最大值

#### 122 获得最高股票数额，不限交易次数

低点买入 高点卖出

极端点想：只要今天比昨天高，就可以卖出，因为一直找到最高处卖，等于中间的每天买入&卖出。

#### 125 判断字母类是否回文

palindrome:回文

⚠️ C++

* 正则替换的使用 //删除掉所有非字母的字符

  regex re("[^a-zA-Z】+");

  s = regex_replace(s,re,"");

* String.replace的使用

  只能单个字符进行替换

  s.replace(s.begin(),s.end()," ","");

* 大小写替换

  transform(s.begin(),s.end(),s.begin(),::tolower);

#### 136 一个非空数组包括n个出现两次的整数，1个出现一次的整数，找到这个整数

将所有的数字亦或，结果就是出现一次的整数

* 亦或：两个相同的数字得0，两个不同的数字得1，和0亦或为本身
* 两个不同位亦或为1，两个相同位亦或为0

#### 155 构造一个可以O(1)获得最小值的stack

构造两个stack，其中一个栈顶是当前最小值，如果大于它的就不入栈

#### 167 一个有序数组求和 twosum

两个指针

#### 169 找众数

用map就行

⚠️C++

* map查找是否存在某个key
  * map.count > 0
  * m.find(key) != m.end()

#### 172 找后缀的0的个数

需要计算有多少个5（因为2的个数远多于5），f(n) = n/5+n/(25) + n/(125)....

#### 190 翻转uint_32二进制字符串

先转换成二进制 然后翻转，再转换为十进制

可以用<<和>>来，比如n&1 == 1，最后一位是1;n&1 == 0,最后一位是0

⚠️C++

* 初始化string
  * string s(32,'0');

#### 191 计算一个uint_32中1的个数

同上一题

#### 198 不能相邻抢劫，求抢劫最大值

动态规划

当前为i

维护三个值：

two_all_max：以[0-i-2]为抢劫结束点的中的最大值

one_max: 以i-1为抢劫结束点的最大值

all_max：所有之前抢劫结束点的最大值，也就是返回值

#### 203 删除链表中的特定节点

由于当要删除的节点是头部的节点的时候，会需要特殊的处理，所以增加一个虚拟头节点dummy

维护节点：now，prev，next



